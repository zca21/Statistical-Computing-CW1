---
title: "Untitled"
output: html_document
date: "2022-10-31"
---

## Question 1: Wild Life Population Density
```{r}
#a
#Initialising the enviroment
setwd("~/Desktop/Statistical Computing/CW/Statistical-Computing-CW1")
eco.df <- read.table("ecoStudy.txt",header = T)
#Turning habitat variable into factor for later plotting and analysis using it
eco.df$habitat <- factor(eco.df$habitat,levels=c("A","B","C"),labels=c("A","B","C"))
attach(eco.df)

#i
#For these questions I will report my answers to 3 d.p.

min(density)
#minimum density is 0

#Selecting 1st quantile from the density column of eco-study dataset
quantile(density)[[2]]
#1st quantile of density is 1.413 to (3 d.p.)

median(density)
#Median of density is 2.744 (3 d.p.)

#Selecting 3rd quantile
quantile(density)[[4]]
#3rd quantile of density is 4.193 (3 d.p.)

max(density)
#maximum value of desnity is 20.497 (3 d.p.)

#ii
table(habitat)
#For habitat A, B and C there are 100, 125 and 75 observations in each respectively
```

```{r}
#b
#Creating new column in eco-study dataframe
eco.df$logDensity <- log(density + 1)

#Saving plot created below
pdf(file="Boxplot.pdf")

#Creating graphic of side by side box plots
par(mfrow=c(2,1))

boxplot(density~habitat,
        main="Boxplot of density in each habitat",
        xlab="Habitat type",
        ylab="Density",
        col=c("red","blue","green"))

boxplot(logDensity~habitat,
        main="Boxplot of log density in each habitat",
        xlab="Habitat type",
        ylab="Log density",
        col=c("red","blue","green"))

dev.off()

#NEED TO SORT OUT SAVING THIS PROPERLY
```
```{r}
#Creating vectors to store the observed densities of each habitat type
density.A <- density[habitat=="A"]
density.B <- density[habitat=="B"]
density.C <- density[habitat=="C"]

#calculating the denominator
F.stat.denom <- (sum((density.A-mean(density.A))^2)+
  sum((density.B-mean(density.B))^2)+
  sum((density.C-mean(density.C))^2))/(300-3)

#calculating the numerator
F.stat.numerator <- ((100*((mean(density.A)-mean(density))^2))+
  (125*((mean(density.B)-mean(density))^2))+
  (75*((mean(density.C)-mean(density))^2)))/2

#Calculating F statistic
F.stat <- F.stat.numerator/F.stat.denom

#Finding p-value, as pf is probability that x from a RV X~F_{2}{297} is less than F.stat value the probability to be equal or larger is 1-pf
1-pf(F.stat,2,297)


#Using tapply to find the F-stat instead

#First, creating a function to calculate the numerator and denominator values for each habitat type
F.stat <- function(vec=NULL){
  
  numerator<-(length(vec)*(mean(vec)-mean(density))^2)/2
  denominator<-(sum((vec-mean(vec))^2))/(300-3)
  
  #Storing in a list so can extract both values from the function output
  output <- list("num"=numerator,"den"=denominator)
  
  return(list("num"=numerator,"den"=denominator))
}

#Applying the function to each habitat type separately using the tapply function
tapply.out.Fstat<-tapply(density,habitat,FUN=F.stat)

#Calculating the F statistic by extracting and summing the numerator and denominator parts of the tapply output
tapply.F.stat<-sum(c(tapply.out.Fstat$A$num,tapply.out.Fstat$B$num,tapply.out.Fstat$C$num))/
  sum(c(tapply.out.Fstat$A$den,tapply.out.Fstat$B$den,tapply.out.Fstat$C$den))
```

```{r}
#function to calculate the residuals in the ith habitat
residual.func<- function(x){

  residuals <- x-mean(x)
  
  return(residuals)
}

#Calculating residuals for each list using tapply
residuals.list <- tapply(density, habitat, residual.func)
#Extracting residuals values from list and putting into a vector
residuals<-c(residuals.list$A,residuals.list$B,residuals.list$C)

#Creating QQ plot
sorted.residuals<-sort(residuals)
sorted.normal.dist<-sort(rnorm(300))

plot(x=sorted.normal.dist,y=sorted.residuals,
     xlab="Theoretical quantiles",
     ylab="Sample quantiles",
     main="QQ plot of residuals")
#Adding in reference line
qqline(residuals, col = "red", lwd = 2)

#Looking at the QQ plot the tails diverge dramatically from the reference line giving evidence that the residuals are not normally distributed.
```

## Question 2: Mixture Models
```{r}
calcLogMix2Gamma <- function(x,alpha,beta,p){
  
  #input argument checking
  if(is.numeric(x)==F){
    stop("x is not a numeric vector")
  }else if(length(alpha)!=2 | is.numeric(alpha)==F){
    stop("alpha needs to a numeric vector of length 2")
  }else if(length(beta)!=2 | is.numeric(beta)==F){
    stop("beta needs to a numeric vector of length 2")
  }else if(is.numeric(p)==F | p>1 | p<0 | length(p)!=1){
    stop("p must be a single numeric value between 0 and 1 inclusive")
  }
  
  #calculating the pdf for each value of x using the provided formula
  prob.dist<-p*(x^(alpha[1]-1)*exp(-beta[1]*x)*beta[1]^alpha[1])/gamma(alpha[1])+(1-p)*(x^(alpha[2]-1)*exp(-beta[2]*x)*beta[2]^alpha[2])/gamma(alpha[2])
  
  #calculating the log of the joint probability distribution
  log.like <- log(prod(prob.dist))
  
  return(log.like)
}


#Creating objects for the function
x <- c(0.06, 2.32, 4.81, 0.02, 2.33, 2.18, 0.83, 2.45, 2.10, 3.27)
alpha <- c(0.5, 6)
beta <- c(0.5, 2.5)
p <- 0.35

#Using calcLogMixGamma function with required inputs and rounding to 3 d.p.
round(calcLogMix2Gamma(x,alpha,beta,p),3)
```


## Question 3: Reimann Integration

```{r}
smoothCurve <- function(x,alpha,beta,p,q,k){
  
  #calculating numerator and denomoinator in log term of g(x) function
  numerator <- (gamma(x+beta)^k)*(p^alpha)*(q^beta)
  denominator <- (gamma(alpha)^k)*(gamma(beta)^k)
  
  #combining parts of g(x) to calculate g(x) value
  g <- sin((1/(2*alpha))*log(numerator/denominator))

  return(g)
}

calcMidRiemannLoop <- function(xVec,alpha,beta,p,q,k){
  #setting up vector to store areas of each (x_{i-1},x_{i}) segment
  interval.area<-rep(0,length(xVec)-1)
  
  #loop to calculate the area in each interval
  for (i in 2:length(xVec)){
    x <- (xVec[i]+xVec[i-1])/2
    #using equation 6 with absoulte value as area cannot be negative
    interval.area <- abs((xVec[i]-xVec[i-1])*smoothCurve(x,alpha,beta,p,q,k))
  }
  
  #Calculating total area
  approx.area <- sum(interval.area)
  
  return(approx.area)
}


```

